<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kongx</title>
  
  <subtitle>We all make choices in life , The hard thing is to live with them !</subtitle>
  <link href="/cleverkx/atom.xml" rel="self"/>
  
  <link href="https://github.com/cleverkx/"/>
  <updated>2019-07-05T08:40:44.885Z</updated>
  <id>https://github.com/cleverkx/</id>
  
  <author>
    <name>kongx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于node的express框架</title>
    <link href="https://github.com/cleverkx/2019/07/05/%E5%9F%BA%E4%BA%8ENode%E7%9A%84express%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/cleverkx/2019/07/05/基于Node的express框架/</id>
    <published>2019-07-05T08:20:00.000Z</published>
    <updated>2019-07-05T08:40:44.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cleverkx\assets\css\APlayer.min.css"><script src="\cleverkx\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用基于node的web开发框架搭建web应用，常见的Nodej框架有express,koa,egg</p><h1 id="一、express的安装和使用"><a href="#一、express的安装和使用" class="headerlink" title="一、express的安装和使用"></a>一、express的安装和使用</h1><h2 id="1-安装方法"><a href="#1-安装方法" class="headerlink" title="1.安装方法"></a>1.安装方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$npm init -y//初始化npm,package.json里名默认为打开安装的文件夹的名称，加-y默认安装的全为yes</span><br><span class="line">$npm install express --save//也可简写为$npm i express -S</span><br></pre></td></tr></table></figure><h2 id="2-创建基本Express-web服务器"><a href="#2-创建基本Express-web服务器" class="headerlink" title="2.创建基本Express web服务器"></a>2.创建基本Express web服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);<span class="comment">//引用上面安装好的express第三方模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);<span class="comment">//引用nodejs自带的核心模块</span></span><br><span class="line"><span class="keyword">const</span> app = express()<span class="comment">//创建web服务器，app名字可以任意取</span></span><br><span class="line"><span class="comment">//处理get请求</span></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.send(<span class="string">'你好!'</span>)<span class="comment">//express封装好的send方法可以输出中文,用默认原生自带的end只能输出英文</span></span><br><span class="line">  res.sendFile(path.join(__dirname,<span class="string">'./views/home.html'</span>))</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(<span class="string">'./views'</span>))<span class="comment">//可以访问views底下的所有文件，如果下面还有文件夹，可以写成例如views/m/index.html，访问到views/底下的m文件夹里的index.html文件,此方法为静态资源托管，在下面会有解释</span></span><br><span class="line"><span class="comment">//处理post请求</span></span><br><span class="line">app.post(<span class="string">'/'</span>,(req,res)=&gt;&#123;&#125;)<span class="comment">//同上处理get请求一样</span></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server running at http://localhost:3000/'</span>)</span><br><span class="line">&#125;)<span class="comment">//参数127.0.0.1可省略,默认使用本地host服务器，设置的端口号为3000，这句话一定要写，此方法为监听服务器启动</span></span><br></pre></td></tr></table></figure><h2 id="3-express两个快捷方法"><a href="#3-express两个快捷方法" class="headerlink" title="3.express两个快捷方法"></a>3.express两个快捷方法</h2><ul><li>1.res.send()<br>  1.支持 发送 字符串 Content-Type:text/html;<pre><code>2.支持 发送 对象 或 数组 Content-Type:application/json3.支持 发送 Buffer 读取文件夹时输出的buffer值为二进制</code></pre></li><li>2.res.sendFile()<br>  用法1：res.sendFile(path.join(<strong>dirname,’./view/index.html’));<br>  用法2:：res.sendFile(‘./view/index.html’,{root:</strong>dirname})<br>  此方法用于向浏览器发送静态页面<h1 id="二、使用express-static托管静态文件"><a href="#二、使用express-static托管静态文件" class="headerlink" title="二、使用express.static托管静态文件"></a>二、使用express.static托管静态文件</h1><h2 id="1-为什么要托管静态文件："><a href="#1-为什么要托管静态文件：" class="headerlink" title="1.为什么要托管静态文件："></a>1.为什么要托管静态文件：</h2>当有很多静态页面时，使用res.sendFile返回页面会很麻烦<h2 id="2-托管方法"><a href="#2-托管方法" class="headerlink" title="2.托管方法"></a>2.托管方法</h2>app.use()方法，是专门用来注册中间件；<br>express.static 是express的内置中间件</li></ul><p>语法1：不加虚拟目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'./views'</span>))</span><br></pre></td></tr></table></figure><p>语法2：加虚拟目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/虚拟目录'</span>,express.static(<span class="string">'./views'</span>))</span><br></pre></td></tr></table></figure><p>访问时必须在目录前加虚拟目录名字，具体注意事项在上面已提及</p><h1 id="三、express使用ejs模板引擎渲染页面"><a href="#三、express使用ejs模板引擎渲染页面" class="headerlink" title="三、express使用ejs模板引擎渲染页面"></a>三、express使用ejs模板引擎渲染页面</h1><h2 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h2><p>1.安装ejs模板引擎 npm i ejs -S<br>2.配置模板引擎类型 app.set(‘view engine’,’ejs’)//固定语法，不可更改<br>3.配置模板文件的存放路径 app.set(‘views’,’./ejs_pages’)//views是固定语法不可更改，ejs_pages为文件存放的本地路径<br>4.在请求处理函数里，使用res.render()来渲染模板页面<br>res.render(‘index.ejs’,{要渲染的数据对象})</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.set(<span class="string">'view engine'</span>,<span class="string">'ejs'</span>);<span class="comment">//设置模板引擎类型</span></span><br><span class="line">app.set(<span class="string">'views'</span>,<span class="string">'./ejs_pages'</span>)<span class="comment">//设置模板文件目录</span></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.render(<span class="string">'index.ejs'</span>,&#123;</span><br><span class="line">    name:<span class="string">'kx'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    hobby:[<span class="string">'吃饭'</span>,<span class="string">'敲代码'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running at http://localhost:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ejs页面里使用方法和语法和art-template的原生语法相同</p><h1 id="四、使用express路由分发请求"><a href="#四、使用express路由分发请求" class="headerlink" title="四、使用express路由分发请求"></a>四、使用express路由分发请求</h1><p>新建一个router.js路由模块，负责创建路由对象并导出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装一个router.js路由模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.Router()<span class="comment">//创建路由对象</span></span><br><span class="line">router.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(<span class="string">'/music'</span>,(req,res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(<span class="string">'/about'</span>,(req,res)=&gt;&#123;&#125;)</span><br><span class="line"><span class="comment">//导出路由对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure></p><p>需要使用路由的文件引用router.js模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入自己的路由模块</span></span><br><span class="line"><span class="keyword">const</span> router =<span class="built_in">require</span>(<span class="string">'./router.js'</span>)</span><br><span class="line"><span class="comment">//使用app.use()来注册路由</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(router);</span><br><span class="line">app.listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running at http://localhost:3000/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\cleverkx\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\cleverkx\assets\js\A
      
    
    </summary>
    
      <category term="nodeJs" scheme="https://github.com/cleverkx/categories/nodeJs/"/>
    
    
      <category term="nodeJs" scheme="https://github.com/cleverkx/tags/nodeJs/"/>
    
      <category term="express" scheme="https://github.com/cleverkx/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>同源和跨域</title>
    <link href="https://github.com/cleverkx/2019/07/03/%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
    <id>https://github.com/cleverkx/2019/07/03/同源和跨域/</id>
    <published>2019-07-03T10:55:00.000Z</published>
    <updated>2019-07-05T08:40:30.941Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cleverkx\assets\css\APlayer.min.css"><script src="\cleverkx\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、同源"><a href="#一、同源" class="headerlink" title="一、同源"></a>一、同源</h1><p>同源策略是浏览器的一种安全策略，所谓同源是指   域名，协议，端口完全相同</p><h1 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h1><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1.什么是跨域"></a>1.什么是跨域</h2><p>简单来说，不同源即跨域。域名，协议，端口有一项不同即跨域，如果只是目录不同，不算跨域。<br>允许跨域的标签：img,link,src,href.<br>跨域不是请求没有发出去，而是发出去之后，服务器也响应了，但是返回的数据被浏览器默认拦截了</p><h2 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2.跨域解决方案"></a>2.跨域解决方案</h2><h3 id="1-服务器端跨域CORS"><a href="#1-服务器端跨域CORS" class="headerlink" title="1.服务器端跨域CORS"></a>1.服务器端跨域CORS</h3><pre><code>在请求的php文件中设置响应头：  header(&quot;Access-Control-Allow-Origin:*&quot;) 允许所有其他域向当前域发送请求。  header(&quot;Access-Control-Allow-Origin:http://www.aa.com&quot;) 允许指定的域向当前域发送请求。  不常用，服务器一般不允许这样设置</code></pre><h3 id="2-JSONP跨域方案"><a href="#2-JSONP跨域方案" class="headerlink" title="2.JSONP跨域方案"></a>2.JSONP跨域方案</h3><h4 id="1-JSONP原理（原生方法）"><a href="#1-JSONP原理（原生方法）" class="headerlink" title="1)JSONP原理（原生方法）"></a>1)JSONP原理（原生方法）</h4><ul><li><p>前台修改：<br>  其本质是利用了<script src></script>标签的src具有可跨域性，将操作数据的函数test拼接为callback的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/comm2.com/i</span>ndex.php?callback=test<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>后台处理:<br>  服务端返回一个预先定义好的javaScript函数的调用，并且将服务器数据以该函数参数的形式传递过来</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$callback = $_GET[<span class="string">"callback"</span>];</span><br><span class="line">$data=file_get_contents(<span class="string">"data.json"</span>);</span><br><span class="line"><span class="keyword">echo</span> $callback.<span class="string">"("</span>.$data.<span class="string">")"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>此方法只能以GET方式请求</p><h4 id="2-jquery使用JSONP跨域的步骤"><a href="#2-jquery使用JSONP跨域的步骤" class="headerlink" title="2)jquery使用JSONP跨域的步骤"></a>2)jquery使用JSONP跨域的步骤</h4><ul><li>前台修改：在ajax请求里设置dataType为jsonp，这一步骤本质将上面的原理封装好了，直接可以开启跨域请求<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  type:<span class="string">'get'</span>,</span><br><span class="line">  dataType:<span class="string">'jsonp'</span>,</span><br><span class="line">  url:<span class="string">'http://comm2.com/index.php'</span>,</span><br><span class="line">  success: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>这种后台直接给前台请求的返回值，无需前台传数据</p><h3 id="3-反向代理服务器跨域方案"><a href="#3-反向代理服务器跨域方案" class="headerlink" title="3.反向代理服务器跨域方案"></a>3.反向代理服务器跨域方案</h3><p>反向代理其实就是，前端人员配置个代理服务器来接受客户端的请求，然后将请求发给真正的服务器，真正的做处理的服务器将处理结果返回给代理服务器，代理服务器再将结果发送给客户端。此方法利用的就是服务器与服务器之间不存在跨域的特性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\cleverkx\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\cleverkx\assets\js\A
      
    
    </summary>
    
      <category term="同源和跨域" scheme="https://github.com/cleverkx/categories/%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/"/>
    
    
      <category term="同源" scheme="https://github.com/cleverkx/tags/%E5%90%8C%E6%BA%90/"/>
    
      <category term="跨域" scheme="https://github.com/cleverkx/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>nodeJs介绍和ES6语法</title>
    <link href="https://github.com/cleverkx/2019/07/02/nodeJs%E4%BB%8B%E7%BB%8D%E5%92%8CES6%E8%AF%AD%E6%B3%95/"/>
    <id>https://github.com/cleverkx/2019/07/02/nodeJs介绍和ES6语法/</id>
    <published>2019-07-02T03:30:00.000Z</published>
    <updated>2019-07-02T03:25:26.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cleverkx\assets\css\APlayer.min.css"><script src="\cleverkx\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="1-什么是node-js"><a href="#1-什么是node-js" class="headerlink" title="1.什么是node.js"></a>1.什么是node.js</h2><p>简单来说 node.js就是一个基于Chrome V8 引擎的一个运行环境<br>例如：</p><ul><li>java 安装 tomcat 环境</li><li>php  安装 phpstudy（安装了才可以执行php） 环境</li><li>python 安装对应python  环境</li><li>javascript 语言，对于我们平时开发中，前端必须打开浏览器，他才会执行，对于我们而言，浏览器就是我们前端执行JS的环境，而node.js可以将JS变成后端，可以操作数据库</li></ul><h2 id="2-nodeJS中javascript的组成部分"><a href="#2-nodeJS中javascript的组成部分" class="headerlink" title="2.nodeJS中javascript的组成部分"></a>2.nodeJS中javascript的组成部分</h2><p>ECMAscript核心+全局成员+核心API模块<br>nodejs无需操作浏览器，没有BOM和DOM的概念，取而代之的是全局成员和核心API</p><h2 id="3-运行nodeJS的方式"><a href="#3-运行nodeJS的方式" class="headerlink" title="3.运行nodeJS的方式"></a>3.运行nodeJS的方式</h2><ul><li>在powershell或者vscode的终端中输入node xx.js（注意：运行的JS文件要保证在你终端文件路径下有这个文件，注意路径问题）</li><li>使用repl方式，先输入node，进入repl命令，再输入js代码，这种方法不常用，对于开发人员代码编写很不友好</li></ul><h2 id="4-path环境变量"><a href="#4-path环境变量" class="headerlink" title="4.path环境变量"></a>4.path环境变量</h2><p>在Windows的高级系统设置里面设置Path环境变量为应用程序的路径，这样就可以在命令行快速启动应用程序</p><h1 id="二、ES6常用语法"><a href="#二、ES6常用语法" class="headerlink" title="二、ES6常用语法"></a>二、ES6常用语法</h1><h2 id="1-let和const声明变量"><a href="#1-let和const声明变量" class="headerlink" title="1.let和const声明变量"></a>1.let和const声明变量</h2><p>使用var定义变量存在预解析变量提升的问题；<br>使用var定义的变量没有块级{}作用域，容易造成变量污染</p><p>在ES6语法中使用let定义变量，不会产生变量提升，只能先定义再使用；在{}里使用let定义的变量会产生块级作用域，在{}之外不能访问，例如在if,for等里面<br>在ES6语法中也少量使用const声明常量，它除了具有let的特点之外，必须给初始值，不能被重新赋值修改</p><h2 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h2><p>定义：从对象中把属性解放出来，当做变量来使用。语法：let{属性名1，属性名2}=对象名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">'kongx'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: username, age&#125; = user;</span><br><span class="line">username = <span class="string">'man'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(username)<span class="comment">//输出值为man</span></span><br><span class="line"><span class="built_in">console</span>.log(age)<span class="comment">//输出值为18</span></span><br><span class="line"><span class="built_in">console</span>.log(user.name)<span class="comment">//输出值为kongx，let解构赋值不会改变对象属性名对应的属性值</span></span><br></pre></td></tr></table></figure><h2 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3.箭头函数"></a>3.箭头函数</h2><p>语法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;函数体&#125;;</span><br></pre></td></tr></table></figure></p><p>箭头函数函数实际就是一个匿名函数，没有函数名<br>箭头函数内部的this永远指向外部的this，解决了原生JS的需要修改this指向问题<br>同时可以给箭头函数取名字：let kongx = (形参) =&gt; {函数体}</p><p>箭头函数的变体：</p><ul><li>1.如果左侧形参只有一个，左侧的()可以省略</li><li>2.如果右侧函数体代码只有一行，右侧的{}可以省略，默认会返回执行结果，不能再加return</li><li>3.如果满足上面两个条件，可以同时省略()和{}</li></ul><h2 id="4-定义对象中的属性和方法的快捷方式"><a href="#4-定义对象中的属性和方法的快捷方式" class="headerlink" title="4.定义对象中的属性和方法的快捷方式"></a>4.定义对象中的属性和方法的快捷方式</h2><p>语法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"kongx"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;name,age,show,say()&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>对象的属性名和变量名相同时，不需要再写一次变量名，相当于”name”:name 省略成name,方法同理<br>对象内定义方法时say(){}相当于say:function(){}</p><h2 id="5-ES6模板字符串"><a href="#5-ES6模板字符串" class="headerlink" title="5.ES6模板字符串"></a>5.ES6模板字符串</h2><p>在javaScript拼接字符串时，需要使用大量的引号和+拼接才能得到我们需要的内容<br>ES6中提供了模板字符串，用 ` (反引号)标识，用${变量}将变量加入到反引号里面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`I age is <span class="subst">$&#123;age&#125;</span>`</span></span><br></pre></td></tr></table></figure></p><p>注意：模板字符串中的换行和空格都会原样输出</p><ul><li><p>在${}中的大括号里可以放入任意的javaScript表达式，还可以进行运算，以及引用对象属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">let</span> y=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a=<span class="subst">$&#123;++x&#125;</span>,y=<span class="subst">$&#123;x+y&#125;</span>`</span>);<span class="comment">//a=10,y=20</span></span><br></pre></td></tr></table></figure></li><li><p>模板字符串还可以调用函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> say = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"i like es6"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`我想说<span class="subst">$&#123;say()&#125;</span>`</span>)<span class="comment">//我想说i like es6</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\cleverkx\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\cleverkx\assets\js\A
      
    
    </summary>
    
      <category term="nodeJs" scheme="https://github.com/cleverkx/categories/nodeJs/"/>
    
    
      <category term="nodeJs" scheme="https://github.com/cleverkx/tags/nodeJs/"/>
    
      <category term="ES6" scheme="https://github.com/cleverkx/tags/ES6/"/>
    
  </entry>
  
</feed>
