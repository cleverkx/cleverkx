<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于node的express框架]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F05%2F%E5%9F%BA%E4%BA%8ENode%E7%9A%84express%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[使用基于node的web开发框架搭建web应用，常见的Nodej框架有express,koa,egg 一、express的安装和使用1.安装方法12$npm init -y//初始化npm,package.json里名默认为打开安装的文件夹的名称，加-y默认安装的全为yes$npm install express --save//也可简写为$npm i express -S 2.创建基本Express web服务器1234567891011121314const express = require('express');//引用上面安装好的express第三方模块const path = require('path');//引用nodejs自带的核心模块const app = express()//创建web服务器，app名字可以任意取//处理get请求app.get('/',(req,res)=&gt;&#123; //res.send('你好!')//express封装好的send方法可以输出中文,用默认原生自带的end只能输出英文 res.sendFile(path.join(__dirname,'./views/home.html'))&#125;)app.use(express.static('./views'))//可以访问views底下的所有文件，如果下面还有文件夹，可以写成例如views/m/index.html，访问到views/底下的m文件夹里的index.html文件,此方法为静态资源托管，在下面会有解释//处理post请求app.post('/',(req,res)=&gt;&#123;&#125;)//同上处理get请求一样app.listen(3000,'127.0.0.1',()=&gt;&#123; console.log('server running at http://localhost:3000/')&#125;)//参数127.0.0.1可省略,默认使用本地host服务器，设置的端口号为3000，这句话一定要写，此方法为监听服务器启动 3.express两个快捷方法 1.res.send() 1.支持 发送 字符串 Content-Type:text/html; 2.支持 发送 对象 或 数组 Content-Type:application/json 3.支持 发送 Buffer 读取文件夹时输出的buffer值为二进制 2.res.sendFile()用法1：res.sendFile(path.join(dirname,’./view/index.html’));用法2:：res.sendFile(‘./view/index.html’,{root:dirname})此方法用于向浏览器发送静态页面二、使用express.static托管静态文件1.为什么要托管静态文件：当有很多静态页面时，使用res.sendFile返回页面会很麻烦2.托管方法app.use()方法，是专门用来注册中间件；express.static 是express的内置中间件 语法1：不加虚拟目录 1app.use(express.static('./views')) 语法2：加虚拟目录 1app.use('/虚拟目录',express.static('./views')) 访问时必须在目录前加虚拟目录名字，具体注意事项在上面已提及 三、express使用ejs模板引擎渲染页面1.使用方法1.安装ejs模板引擎 npm i ejs -S2.配置模板引擎类型 app.set(‘view engine’,’ejs’)//固定语法，不可更改3.配置模板文件的存放路径 app.set(‘views’,’./ejs_pages’)//views是固定语法不可更改，ejs_pages为文件存放的本地路径4.在请求处理函数里，使用res.render()来渲染模板页面res.render(‘index.ejs’,{要渲染的数据对象}) 1234567891011121314const express = require('express');const app = express();app.set('view engine','ejs');//设置模板引擎类型app.set('views','./ejs_pages')//设置模板文件目录app.get('/',(req,res)=&gt;&#123; res.render('index.ejs',&#123; name:'kx', age:18, hobby:['吃饭','敲代码'] &#125;)&#125;)app.listen(3000,()=&gt;&#123; console.log('server is running at http://localhost:3000/')&#125;) ejs页面里使用方法和语法和art-template的原生语法相同 四、使用express路由分发请求新建一个router.js路由模块，负责创建路由对象并导出12345678//封装一个router.js路由模块const express = require('express')const router = express.Router()//创建路由对象router.get('/',(req,res)=&gt;&#123;&#125;)router.get('/music',(req,res)=&gt;&#123;&#125;)router.get('/about',(req,res)=&gt;&#123;&#125;)//导出路由对象module.exports = router 需要使用路由的文件引用router.js模块123456789//导入自己的路由模块const router =require('./router.js')//使用app.use()来注册路由const express = require('express');const app = express();app.use(router);app.listen(3000,()=&gt;&#123; console.log('server is running at http://localhost:3000/')&#125;) 五、中间件的概念上面文章中说到app.use是注册中间件用的，那么什么是中间件呢？ 1.什么是中间件中间件其实就是一个处理函数，形参包含三个参数：req(请求对象),res(响应对象),next(调用下一个中间件) 只要地址栏发送了请求就会执行中间件 想要继续执行中间件，必须在函数内调用next()方法 req,res在nodejs不同的中间件里都是同一个对象 2.express中间件的分类 1.应用级别的中间件：挂载到app上的中间件 1app.get('url地址',(req,res,next) =&gt; &#123;&#125;) 2.路由级别的中间件：挂载到router对象上的中间件 1router.get('url地址',(req,res,next) =&gt; &#123;&#125;) 3.错误级别的中间件：回调函数中，有四个参数 1app.use((err,req,res,next) =&gt; &#123;&#125;)//最常用 4.唯一内置的中间件 1app.use(express.static('./view'))//托管静态文件使用 5.第三方中间件：非express框架提供的，需要程序员手动安装才能使用的中间件 body-parser 解析post表单数据 六、express操作mysql数据库使用express对Mysql数据库进行增删改查 1.安装数据库模块1npm i mysql -S 2.导入mysql模块1const mysql = require('mysql') 3. 创建连接对象123456const conn = mysql.createConnection(&#123; host:'主机名', user:'用户名', password:'密码', database:'数据库名'&#125;) 4.执行sql语句1conn.query('sql语句','需要修改添加的对象，如果没有可省略',(err,result) =&gt;&#123;&#125;) 新增语句 可以使用 ? 占位符 + 数据对象实现：只能在node的mysql语句支持 以前的sql语句也可以使用 123456const user = &#123;uname:'小黄',age:12,gender:'男'&#125;const sql = 'insert into user set?'conn.query(sql,user,(err.result)=&gt;&#123; if(err) return res.send(err.message); console.log(result)&#125;) 修改语句 如果有多个 ? 占位符；数据对象有多个，要使用数组形式传递 123456const user = &#123;id:2,uname:'kx',age:18&#125;;const sql = 'update users set ? where id=?';conn.query(sql,[user,user.id],(err.result)=&gt;&#123; if(err) return res.send(err.message); console.log(result)&#125;) 七、express获取参数1.使用req.query获取参数地址栏参数要为这种形式:http://127.0.0.1:3000?name=kx&amp;age=18req.query获取查询参数(查询参数：直接在地址栏后面拼接的参数)使用postman发送get请求方式,获取到查询参数:1234app.get('/user',(req,res)=&gt;&#123; console.log(req.query)//&#123;name:'kx',age:18&#125; res.send('请求成功')//给前台的数据显示请求成功&#125;) 2.使用req.params获取参数(get请求最常用的方式)地址栏参数要为这种形式:http://127.0.0.1:3000/user/kx/18使用postman 发送get请求方式获取到参数:1234app.get('/user/:name/:age',(req,res)=&gt;&#123; console.log(req.params)//&#123;name:'kx',age:18&#125; res.send('请求成功')//给前台的数据显示请求成功&#125;) 3. 从post表单获取提交的数据使用postman发送请求 1.需要安装body-parser中间件 1npm i body-parser -S 在处理post请求前注册中间件 12const bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123; extended: false &#125;));//固定格式，不要做修改 3.在请求处理函数里使用req.body获取post提交的数据(得到的为对象格式) 1234app.post('/user',(req,res) =&gt; &#123; cosole.log(req.body)//&#123;name:'kx',age:18&#125; res.send('请求成功')&#125;)]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源和跨域]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F03%2F%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一、同源同源策略是浏览器的一种安全策略，所谓同源是指 域名，协议，端口完全相同 二、跨域1.什么是跨域简单来说，不同源即跨域。域名，协议，端口有一项不同即跨域，如果只是目录不同，不算跨域。允许跨域的标签：img,link,src,href.跨域不是请求没有发出去，而是发出去之后，服务器也响应了，但是返回的数据被浏览器默认拦截了 2.跨域解决方案1.服务器端跨域CORS在请求的php文件中设置响应头： header(&quot;Access-Control-Allow-Origin:*&quot;) 允许所有其他域向当前域发送请求。 header(&quot;Access-Control-Allow-Origin:http://www.aa.com&quot;) 允许指定的域向当前域发送请求。 不常用，服务器一般不允许这样设置 2.JSONP跨域方案1)JSONP原理（原生方法） 前台修改： 其本质是利用了标签的src具有可跨域性，将操作数据的函数test拼接为callback的值 1234&lt;script&gt;let test = data =&gt; console.log(data)&lt;/script&gt;&lt;script src="http://comm2.com/index.php?callback=test"&gt;&lt;/script&gt; 后台处理: 服务端返回一个预先定义好的javaScript函数的调用，并且将服务器数据以该函数参数的形式传递过来 12345&lt;?php$callback = $_GET["callback"];$data=file_get_contents("data.json");echo $callback."(".$data.")";?&gt; 此方法只能以GET方式请求 2)jquery使用JSONP跨域的步骤 前台修改：在ajax请求里设置dataType为jsonp，这一步骤本质将上面的原理封装好了，直接可以开启跨域请求123456$.ajax(&#123; type:'get', dataType:'jsonp', url:'http://comm2.com/index.php', success: data =&gt; console.log(data)&#125;) 这种后台直接给前台请求的返回值，无需前台传数据 3.反向代理服务器跨域方案反向代理其实就是，前端人员配置个代理服务器来接受客户端的请求，然后将请求发给真正的服务器，真正的做处理的服务器将处理结果返回给代理服务器，代理服务器再将结果发送给客户端。此方法利用的就是服务器与服务器之间不存在跨域的特性。]]></content>
      <categories>
        <category>同源和跨域</category>
      </categories>
      <tags>
        <tag>同源</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs介绍和ES6语法]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F02%2FnodeJs%E4%BB%8B%E7%BB%8D%E5%92%8CES6%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、概念1.什么是node.js简单来说 node.js就是一个基于Chrome V8 引擎的一个运行环境例如： java 安装 tomcat 环境 php 安装 phpstudy（安装了才可以执行php） 环境 python 安装对应python 环境 javascript 语言，对于我们平时开发中，前端必须打开浏览器，他才会执行，对于我们而言，浏览器就是我们前端执行JS的环境，而node.js可以将JS变成后端，可以操作数据库 2.nodeJS中javascript的组成部分ECMAscript核心+全局成员+核心API模块nodejs无需操作浏览器，没有BOM和DOM的概念，取而代之的是全局成员和核心API 3.运行nodeJS的方式 在powershell或者vscode的终端中输入node xx.js（注意：运行的JS文件要保证在你终端文件路径下有这个文件，注意路径问题） 使用repl方式，先输入node，进入repl命令，再输入js代码，这种方法不常用，对于开发人员代码编写很不友好 4.path环境变量在Windows的高级系统设置里面设置Path环境变量为应用程序的路径，这样就可以在命令行快速启动应用程序 二、ES6常用语法1.let和const声明变量使用var定义变量存在预解析变量提升的问题；使用var定义的变量没有块级{}作用域，容易造成变量污染 在ES6语法中使用let定义变量，不会产生变量提升，只能先定义再使用；在{}里使用let定义的变量会产生块级作用域，在{}之外不能访问，例如在if,for等里面在ES6语法中也少量使用const声明常量，它除了具有let的特点之外，必须给初始值，不能被重新赋值修改 2.解构赋值定义：从对象中把属性解放出来，当做变量来使用。语法：let{属性名1，属性名2}=对象名 123456789let user = &#123; name: 'kongx', age: 18,&#125;let &#123; name: username, age&#125; = user;username = 'man';console.log(username)//输出值为manconsole.log(age)//输出值为18console.log(user.name)//输出值为kongx，let解构赋值不会改变对象属性名对应的属性值 3.箭头函数语法:1() =&gt; &#123;函数体&#125;; 箭头函数函数实际就是一个匿名函数，没有函数名箭头函数内部的this永远指向外部的this，解决了原生JS的需要修改this指向问题同时可以给箭头函数取名字：let kongx = (形参) =&gt; {函数体} 箭头函数的变体： 1.如果左侧形参只有一个，左侧的()可以省略 2.如果右侧函数体代码只有一行，右侧的{}可以省略，默认会返回执行结果，不能再加return 3.如果满足上面两个条件，可以同时省略()和{} 4.定义对象中的属性和方法的快捷方式语法:1234let name = "kongx";let age = 18;function show()&#123;&#125;let person = &#123;name,age,show,say()&#123;&#125;&#125; 对象的属性名和变量名相同时，不需要再写一次变量名，相当于”name”:name 省略成name,方法同理对象内定义方法时say(){}相当于say:function(){} 5.ES6模板字符串在javaScript拼接字符串时，需要使用大量的引号和+拼接才能得到我们需要的内容ES6中提供了模板字符串，用 ` (反引号)标识，用${变量}将变量加入到反引号里面1`I age is $&#123;age&#125;` 注意：模板字符串中的换行和空格都会原样输出 在${}中的大括号里可以放入任意的javaScript表达式，还可以进行运算，以及引用对象属性 123let x=9;let y=10;console.log(`a=$&#123;++x&#125;,y=$&#123;x+y&#125;`);//a=10,y=20 模板字符串还可以调用函数: 12let say = () =&gt; "i like es6";console.log(`我想说$&#123;say()&#125;`)//我想说i like es6]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基本安装和使用]]></title>
    <url>%2Fcleverkx%2F2019%2F06%2F03%2Fgit%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. Git基础1.1 版本管理1.1.1 什么是版本管理版本管理是一种记录文件变化的方式，以便将来查阅特定版本的文件内容。 1.1.2 人为维护文档版本的问题 文档数量多且命名不清晰导致文档版本混乱 每次编辑文档需要复制，不方便 多人同时编辑同一个文档，容易产生覆盖 1.2 Git 是什么Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。 1.3 Git 安装下载地址 在安装的过程中，所有选项使用默认值即可。 1.4 Git 基本工作流程 git仓库 暂存区 工作目录 用于存放提交记录 临时存放被修改文件 被Git管理的项目目录 1.5 Git 的使用1.5.1 Git 使用前配置在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。 配置提交人姓名：git config --global user.name 提交人姓名 配置提交人姓名：git config --global user.email 提交人邮箱 查看git配置信息：git config --list 注意 如果要对配置信息进行修改，重复上述命令即可。 配置只需要执行一次。 1.5.2 提交步骤（重要） git init 初始化git仓库 （只需要一次就行） git status 查看文件状态 git add 文件列表//add后加.表示上传所有文件 追踪文件 git commit -m 提交信息//提交的信息就是你更新的上传的日常更改备注 向仓库中提交代码// git log 查看提交记录 1.5.2 （每次提交必须要做的事） git add . 添加要提交的文件 git commit -m ‘登录功能完成’ 提交到仓库 git remote add origin https://gitee.com/xx/xx.git 给地址取个名字叫 origin git push -u origin master 提交到远程仓库(如果配置了ssh公用秘钥第三步就可以不用执行，第四步换成git push ssh地址 master) 1.5.3 撤销(了解) 用暂存区中的文件覆盖工作目录中的文件： git checkout 文件 将文件从暂存区中删除： git rm --cached 文件 将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：git rest --hard commitID 2. Git进阶2.1 分支为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本。 使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。 2.1.1 分支命令 git branch 查看分支 git branch 分支名称 创建分支 git checkout 分支名称 切换分支或者 git checkout -b 分支名称 直接创建并且切换分支 git merge 来源分支 合并分支 去master执行 合并其他分支 git branch -d 分支名称 删除分支（分支被合并后才允许删除）（-D 强制删除） 2.2 暂时保存更改在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。 使用场景：分支临时切换 存储临时改动：git stash 恢复改动：git stash pop 3. Gitee中国这里注册我就不写了。 3.1 多人协作开发流程 A在自己的计算机中创建本地仓库 A在github中创建远程仓库 A将本地仓库推送到远程仓库 B克隆远程仓库到本地进行开发 B将本地仓库中开发的内容推送到远程仓库 A将远程仓库中的最新内容拉去到本地 3.2 创建仓库 填写仓库基本信息 将本地仓库推送到远程仓库 git push 远程仓库地址 分支名称 git push 远程仓库地址别名 分支名称 git push -u 远程仓库地址别名 分支名称 -u 记住推送地址及分支，下次推送只需要输入git push即可 git remote add 远程仓库地址别名 远程仓库地址 3.3 拉取操作3.3.1 克隆仓库克隆远端数据仓库到本地：git clone 仓库地址 3.3.2 拉取远程仓库中最新的版本拉取远程仓库中最新的版本：git pull 远程仓库地址 分支名称 3.4 解决冲突在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。 3.5 跨团队协作 程序员 C fork仓库 程序员 C 将仓库克隆在本地进行修改 程序员 C 将仓库推送到远程 程序员 C 发起pull reqest 原仓库作者审核 原仓库作者合并代码 3.6 ssh免登陆码云配置ssh文档：https://gitee.com/help/articles/4181配置ssh公钥私钥 https协议仓库地址：https://github.com/itcast-frontEnd/git-demo.git 生成秘钥：ssh-keygen 秘钥存储目录：C:\Users\用户\.ssh 公钥名称：id_rsa.pub 私钥名称：id_rsa 3.7 GIT忽略清单将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。 git忽略清单文件名称：.gitignore 将工作目录中的文件全部添加到暂存区：git add .]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
