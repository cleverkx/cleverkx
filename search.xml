<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[同源和跨域]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F03%2F%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一、同源同源策略是浏览器的一种安全策略，所谓同源是指 域名，协议，端口完全相同 二、跨域1.什么是跨域简单来说，不同源即跨域。域名，协议，端口有一项不同即跨域，如果只是目录不同，不算跨域。允许跨域的标签：img,link,src,href.跨域不是请求没有发出去，而是发出去之后，服务器也响应了，但是返回的数据被浏览器默认拦截了 2.跨域解决方案1.服务器端跨域CORS在请求的php文件中设置响应头： header(&quot;Access-Control-Allow-Origin:*&quot;) 允许所有其他域向当前域发送请求。 header(&quot;Access-Control-Allow-Origin:http://www.aa.com&quot;) 允许指定的域向当前域发送请求。 不常用，服务器一般不允许这样设置 2.JSONP跨域方案1)JSONP原理（原生方法） 前台修改： 其本质是利用了标签的src具有可跨域性，将操作数据的函数test拼接为callback的值 1234&lt;script&gt;let test = data =&gt; console.log(data)&lt;/script&gt;&lt;script src="http://comm2.com/index.php?callback=test"&gt;&lt;/script&gt; 后台处理: 服务端返回一个预先定义好的javaScript函数的调用，并且将服务器数据以该函数参数的形式传递过来 12345&lt;?php$callback = $_GET["callback"];$data=file_get_contents("data.json");echo $callback."(".$data.")";?&gt; 此方法只能以GET方式请求 2)jquery使用JSONP跨域的步骤 前台修改：在ajax请求里设置dataType为jsonp，这一步骤本质将上面的原理封装好了，直接可以开启跨域请求123456$.ajax(&#123; type:'get', dataType:'jsonp', url:'http://comm2.com/index.php', success: data =&gt; console.log(data)&#125;) 这种后台直接给前台请求的返回值，无需前台传数据 3.反向代理服务器跨域方案反向代理其实就是，前端人员配置个代理服务器来接受客户端的请求，然后将请求发给真正的服务器，真正的做处理的服务器将处理结果返回给代理服务器，代理服务器再将结果发送给客户端。此方法利用的就是服务器与服务器之间不存在跨域的特性。]]></content>
      <categories>
        <category>同源和跨域</category>
      </categories>
      <tags>
        <tag>同源</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs介绍和ES6语法]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F02%2FnodeJs%E4%BB%8B%E7%BB%8D%E5%92%8CES6%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、概念1.什么是node.js简单来说 node.js就是一个基于Chrome V8 引擎的一个运行环境例如： java 安装 tomcat 环境 php 安装 phpstudy（安装了才可以执行php） 环境 python 安装对应python 环境 javascript 语言，对于我们平时开发中，前端必须打开浏览器，他才会执行，对于我们而言，浏览器就是我们前端执行JS的环境，而node.js可以将JS变成后端，可以操作数据库 2.nodeJS中javascript的组成部分ECMAscript核心+全局成员+核心API模块nodejs无需操作浏览器，没有BOM和DOM的概念，取而代之的是全局成员和核心API 3.运行nodeJS的方式 在powershell或者vscode的终端中输入node xx.js（注意：运行的JS文件要保证在你终端文件路径下有这个文件，注意路径问题） 使用repl方式，先输入node，进入repl命令，再输入js代码，这种方法不常用，对于开发人员代码编写很不友好 4.path环境变量在Windows的高级系统设置里面设置Path环境变量为应用程序的路径，这样就可以在命令行快速启动应用程序 二、ES6常用语法1.let和const声明变量使用var定义变量存在预解析变量提升的问题；使用var定义的变量没有块级{}作用域，容易造成变量污染 在ES6语法中使用let定义变量，不会产生变量提升，只能先定义再使用；在{}里使用let定义的变量会产生块级作用域，在{}之外不能访问，例如在if,for等里面在ES6语法中也少量使用const声明常量，它除了具有let的特点之外，必须给初始值，不能被重新赋值修改 2.解构赋值定义：从对象中把属性解放出来，当做变量来使用。语法：let{属性名1，属性名2}=对象名 123456789let user = &#123; name: 'kongx', age: 18,&#125;let &#123; name: username, age&#125; = user;username = 'man';console.log(username)//输出值为manconsole.log(age)//输出值为18console.log(user.name)//输出值为kongx，let解构赋值不会改变对象属性名对应的属性值 3.箭头函数语法:1() =&gt; &#123;函数体&#125;; 箭头函数函数实际就是一个匿名函数，没有函数名箭头函数内部的this永远指向外部的this，解决了原生JS的需要修改this指向问题同时可以给箭头函数取名字：let kongx = (形参) =&gt; {函数体} 箭头函数的变体： 1.如果左侧形参只有一个，左侧的()可以省略 2.如果右侧函数体代码只有一行，右侧的{}可以省略，默认会返回执行结果，不能再加return 3.如果满足上面两个条件，可以同时省略()和{} 4.定义对象中的属性和方法的快捷方式语法:1234let name = "kongx";let age = 18;function show()&#123;&#125;let person = &#123;name,age,show,say()&#123;&#125;&#125; 对象的属性名和变量名相同时，不需要再写一次变量名，相当于”name”:name 省略成name,方法同理对象内定义方法时say(){}相当于say:function(){} 5.ES6模板字符串在javaScript拼接字符串时，需要使用大量的引号和+拼接才能得到我们需要的内容ES6中提供了模板字符串，用 ` (反引号)标识，用${变量}将变量加入到反引号里面1`I age is $&#123;age&#125;` 注意：模板字符串中的换行和空格都会原样输出 在${}中的大括号里可以放入任意的javaScript表达式，还可以进行运算，以及引用对象属性 123let x=9;let y=10;console.log(`a=$&#123;++x&#125;,y=$&#123;x+y&#125;`);//a=10,y=20 模板字符串还可以调用函数: 12let say = () =&gt; "i like es6";console.log(`我想说$&#123;say()&#125;`)//我想说i like es6]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
