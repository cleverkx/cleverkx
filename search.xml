<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于node的express框架]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F05%2F%E5%9F%BA%E4%BA%8ENode%E7%9A%84express%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[使用基于node的web开发框架搭建web应用，常见的Nodej框架有express,koa,egg 一、express的安装和使用1.安装方法12$npm init -y//初始化npm,package.json里名默认为打开安装的文件夹的名称，加-y默认安装的全为yes$npm install express --save//也可简写为$npm i express -S 2.创建基本Express web服务器1234567891011121314const express = require('express');//引用上面安装好的express第三方模块const path = require('path');//引用nodejs自带的核心模块const app = express()//创建web服务器，app名字可以任意取//处理get请求app.get('/',(req,res)=&gt;&#123; //res.send('你好!')//express封装好的send方法可以输出中文,用默认原生自带的end只能输出英文 res.sendFile(path.join(__dirname,'./views/home.html'))&#125;)app.use(express.static('./views'))//可以访问views底下的所有文件，如果下面还有文件夹，可以写成例如views/m/index.html，访问到views/底下的m文件夹里的index.html文件,此方法为静态资源托管，在下面会有解释//处理post请求app.post('/',(req,res)=&gt;&#123;&#125;)//同上处理get请求一样app.listen(3000,'127.0.0.1',()=&gt;&#123; console.log('server running at http://localhost:3000/')&#125;)//参数127.0.0.1可省略,默认使用本地host服务器，设置的端口号为3000，这句话一定要写，此方法为监听服务器启动 3.express两个快捷方法 1.res.send() 1.支持 发送 字符串 Content-Type:text/html; 2.支持 发送 对象 或 数组 Content-Type:application/json 3.支持 发送 Buffer 读取文件夹时输出的buffer值为二进制 2.res.sendFile() 用法1：res.sendFile(path.join(dirname,’./view/index.html’)); 用法2:：res.sendFile(‘./view/index.html’,{root:dirname}) 此方法用于向浏览器发送静态页面二、使用express.static托管静态文件1.为什么要托管静态文件：当有很多静态页面时，使用res.sendFile返回页面会很麻烦2.托管方法app.use()方法，是专门用来注册中间件；express.static 是express的内置中间件 语法1：不加虚拟目录 1app.use(express.static('./views')) 语法2：加虚拟目录 1app.use('/虚拟目录',express.static('./views')) 访问时必须在目录前加虚拟目录名字，具体注意事项在上面已提及 三、express使用ejs模板引擎渲染页面1.使用方法1.安装ejs模板引擎 npm i ejs -S2.配置模板引擎类型 app.set(‘view engine’,’ejs’)//固定语法，不可更改3.配置模板文件的存放路径 app.set(‘views’,’./ejs_pages’)//views是固定语法不可更改，ejs_pages为文件存放的本地路径4.在请求处理函数里，使用res.render()来渲染模板页面res.render(‘index.ejs’,{要渲染的数据对象}) 1234567891011121314const express = require('express');const app = express();app.set('view engine','ejs');//设置模板引擎类型app.set('views','./ejs_pages')//设置模板文件目录app.get('/',(req,res)=&gt;&#123; res.render('index.ejs',&#123; name:'kx', age:18, hobby:['吃饭','敲代码'] &#125;)&#125;)app.listen(3000,()=&gt;&#123; console.log('server is running at http://localhost:3000/')&#125;) ejs页面里使用方法和语法和art-template的原生语法相同 四、使用express路由分发请求新建一个router.js路由模块，负责创建路由对象并导出12345678//封装一个router.js路由模块const express = require('express')const router = express.Router()//创建路由对象router.get('/',(req,res)=&gt;&#123;&#125;)router.get('/music',(req,res)=&gt;&#123;&#125;)router.get('/about',(req,res)=&gt;&#123;&#125;)//导出路由对象module.exports = router 需要使用路由的文件引用router.js模块123456789//导入自己的路由模块const router =require('./router.js')//使用app.use()来注册路由const express = require('express');const app = express();app.use(router);app.listen(3000,()=&gt;&#123; console.log('server is running at http://localhost:3000/')&#125;)]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源和跨域]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F03%2F%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一、同源同源策略是浏览器的一种安全策略，所谓同源是指 域名，协议，端口完全相同 二、跨域1.什么是跨域简单来说，不同源即跨域。域名，协议，端口有一项不同即跨域，如果只是目录不同，不算跨域。允许跨域的标签：img,link,src,href.跨域不是请求没有发出去，而是发出去之后，服务器也响应了，但是返回的数据被浏览器默认拦截了 2.跨域解决方案1.服务器端跨域CORS在请求的php文件中设置响应头： header(&quot;Access-Control-Allow-Origin:*&quot;) 允许所有其他域向当前域发送请求。 header(&quot;Access-Control-Allow-Origin:http://www.aa.com&quot;) 允许指定的域向当前域发送请求。 不常用，服务器一般不允许这样设置 2.JSONP跨域方案1)JSONP原理（原生方法） 前台修改： 其本质是利用了标签的src具有可跨域性，将操作数据的函数test拼接为callback的值 1234&lt;script&gt;let test = data =&gt; console.log(data)&lt;/script&gt;&lt;script src="http://comm2.com/index.php?callback=test"&gt;&lt;/script&gt; 后台处理: 服务端返回一个预先定义好的javaScript函数的调用，并且将服务器数据以该函数参数的形式传递过来 12345&lt;?php$callback = $_GET["callback"];$data=file_get_contents("data.json");echo $callback."(".$data.")";?&gt; 此方法只能以GET方式请求 2)jquery使用JSONP跨域的步骤 前台修改：在ajax请求里设置dataType为jsonp，这一步骤本质将上面的原理封装好了，直接可以开启跨域请求123456$.ajax(&#123; type:'get', dataType:'jsonp', url:'http://comm2.com/index.php', success: data =&gt; console.log(data)&#125;) 这种后台直接给前台请求的返回值，无需前台传数据 3.反向代理服务器跨域方案反向代理其实就是，前端人员配置个代理服务器来接受客户端的请求，然后将请求发给真正的服务器，真正的做处理的服务器将处理结果返回给代理服务器，代理服务器再将结果发送给客户端。此方法利用的就是服务器与服务器之间不存在跨域的特性。]]></content>
      <categories>
        <category>同源和跨域</category>
      </categories>
      <tags>
        <tag>同源</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs介绍和ES6语法]]></title>
    <url>%2Fcleverkx%2F2019%2F07%2F02%2FnodeJs%E4%BB%8B%E7%BB%8D%E5%92%8CES6%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、概念1.什么是node.js简单来说 node.js就是一个基于Chrome V8 引擎的一个运行环境例如： java 安装 tomcat 环境 php 安装 phpstudy（安装了才可以执行php） 环境 python 安装对应python 环境 javascript 语言，对于我们平时开发中，前端必须打开浏览器，他才会执行，对于我们而言，浏览器就是我们前端执行JS的环境，而node.js可以将JS变成后端，可以操作数据库 2.nodeJS中javascript的组成部分ECMAscript核心+全局成员+核心API模块nodejs无需操作浏览器，没有BOM和DOM的概念，取而代之的是全局成员和核心API 3.运行nodeJS的方式 在powershell或者vscode的终端中输入node xx.js（注意：运行的JS文件要保证在你终端文件路径下有这个文件，注意路径问题） 使用repl方式，先输入node，进入repl命令，再输入js代码，这种方法不常用，对于开发人员代码编写很不友好 4.path环境变量在Windows的高级系统设置里面设置Path环境变量为应用程序的路径，这样就可以在命令行快速启动应用程序 二、ES6常用语法1.let和const声明变量使用var定义变量存在预解析变量提升的问题；使用var定义的变量没有块级{}作用域，容易造成变量污染 在ES6语法中使用let定义变量，不会产生变量提升，只能先定义再使用；在{}里使用let定义的变量会产生块级作用域，在{}之外不能访问，例如在if,for等里面在ES6语法中也少量使用const声明常量，它除了具有let的特点之外，必须给初始值，不能被重新赋值修改 2.解构赋值定义：从对象中把属性解放出来，当做变量来使用。语法：let{属性名1，属性名2}=对象名 123456789let user = &#123; name: 'kongx', age: 18,&#125;let &#123; name: username, age&#125; = user;username = 'man';console.log(username)//输出值为manconsole.log(age)//输出值为18console.log(user.name)//输出值为kongx，let解构赋值不会改变对象属性名对应的属性值 3.箭头函数语法:1() =&gt; &#123;函数体&#125;; 箭头函数函数实际就是一个匿名函数，没有函数名箭头函数内部的this永远指向外部的this，解决了原生JS的需要修改this指向问题同时可以给箭头函数取名字：let kongx = (形参) =&gt; {函数体} 箭头函数的变体： 1.如果左侧形参只有一个，左侧的()可以省略 2.如果右侧函数体代码只有一行，右侧的{}可以省略，默认会返回执行结果，不能再加return 3.如果满足上面两个条件，可以同时省略()和{} 4.定义对象中的属性和方法的快捷方式语法:1234let name = "kongx";let age = 18;function show()&#123;&#125;let person = &#123;name,age,show,say()&#123;&#125;&#125; 对象的属性名和变量名相同时，不需要再写一次变量名，相当于”name”:name 省略成name,方法同理对象内定义方法时say(){}相当于say:function(){} 5.ES6模板字符串在javaScript拼接字符串时，需要使用大量的引号和+拼接才能得到我们需要的内容ES6中提供了模板字符串，用 ` (反引号)标识，用${变量}将变量加入到反引号里面1`I age is $&#123;age&#125;` 注意：模板字符串中的换行和空格都会原样输出 在${}中的大括号里可以放入任意的javaScript表达式，还可以进行运算，以及引用对象属性 123let x=9;let y=10;console.log(`a=$&#123;++x&#125;,y=$&#123;x+y&#125;`);//a=10,y=20 模板字符串还可以调用函数: 12let say = () =&gt; "i like es6";console.log(`我想说$&#123;say()&#125;`)//我想说i like es6]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
